## Overview & Progress

- [x] 賞賛の声
- [x] 訳者まえがき：NANDからテトリスへ
- [x] まえがき
- [x] イントロダクション：こんにちは、世界の下側
- [x] 1章 ブール論理
  - [x] 1.1 背景
    - [x] 1.1.1 ブール代数
    - [x] 1.1.2 論理ゲート
    - [x] 1.1.3 実際のハードウェア構築
    - [x] 1.1.4 ハードウェア記述言語（HDL）
    - [x] 1.1.5 ハードウェアシミュレーション
  - [x] 1.2 仕様
    - [x] 1.2.1 Nandゲート
    - [x] 1.2.2 基本論理ゲート
    - [x] 1.2.3 多ビットの基本ゲート
    - [x] 1.2.4 多入力の基本ゲート
  - [x] 1.3 実装
  - [x] 1.4 展望
  - [x] 1.5 プロジェクト
- [x] 2章 ブール算術
  - [x] 2.1 背景
  - [x] 2.2 仕様
    - [x] 2.2.1 加算器（Adder）
    - [x] 2.2.2 ALU（算術論理演算器）
  - [x] 2.3 実装
  - [x] 2.4 展望
  - [x] 2.5 プロジェクト
- [x] 3章 順序回路
  - [x] 3.1 背景
  - [x] 3.2 仕様
    - [x] 3.2.1 D型フリップフロップ
    - [x] 3.2.2 レジスタ
    - [x] 3.2.3 メモリ
    - [x] 3.2.4 カウンタ
  - [x] 3.3 実装
  - [x] 3.4 展望
  - [x] 3.5 プロジェクト
- [ ] 4章 機械語
  - [x] 4.1 背景
    - [x] 4.1.1 機械
    - [x] 4.1.2 言語
    - [x] 4.1.3 コマンド
  - [ ] 4.2 Hack機械語の仕様
    - [ ] 4.2.1 概要
    - [ ] 4.2.2 A命令
    - [ ] 4.2.3 C命令
    - [ ] 4.2.4 シンボル
    - [ ] 4.2.5 入出力操作
    - [ ] 4.2.6 シンタックスとファイルフォーマット
  - [ ] 4.3 展望
  - [ ] 4.4 プロジェクト
- [ ] 5章 コンピュータアーキテクチャ
  - [ ] 5.1 背景
    - [ ] 5.1.1 プログラム内蔵方式
    - [ ] 5.1.2 ノイマン型アーキテクチャ
    - [ ] 5.1.3 メモリ
    - [ ] 5.1.4 CPU
    - [ ] 5.1.5 レジスタ
    - [ ] 5.1.6 入出力
  - [ ] 5.2 Hackハードウェアのプラットフォーム仕様
    - [ ] 5.2.1 概観
    - [ ] 5.2.2 CPU
    - [ ] 5.2.3 命令メモリ
    - [ ] 5.2.4 データメモリ
    - [ ] 5.2.5 コンピュータ
  - [ ] 5.3 実装
    - [ ] 5.3.1 CPU
    - [ ] 5.3.2 メモリ
    - [ ] 5.3.3 コンピュータ
  - [ ] 5.4 展望
  - [ ] 5.5 プロジェクト
- [ ] 6章 アセンブラ
  - [ ] 6.1 背景
  - [ ] 6.2 Hackアセンブリからバイナリへの変換の仕様
    - [ ] 6.2.1 構文規約とファイルフォーマット
    - [ ] 6.2.2 命令
    - [ ] 6.2.3 シンボル
    - [ ] 6.2.4 例
  - [ ] 6.3 実装
    - [ ] 6.3.1 Parserモジュール
    - [ ] 6.3.2 Codeモジュール
    - [ ] 6.3.3 シンボルを含まないプログラムのためのアセンブラ
    - [ ] 6.3.4 SymbolTableモジュール
    - [ ] 6.3.5 シンボルを含むプログラムのためのアセンブラ
  - [ ] 6.4 展望
  - [ ] 6.5 プロジェクト
- [ ] 7章 バーチャルマシン#1：スタック操作
  - [ ] 7.1 背景
    - [ ] 7.1.1 バーチャルマシンの理論的枠組み
    - [ ] 7.1.2 スタックマシン
  - [ ] 7.2 VM仕様（第1部）
    - [ ] 7.2.1 概要
    - [ ] 7.2.2 算術と論理コマンド
    - [ ] 7.2.3 メモリアクセスコマンド
    - [ ] 7.2.4 プログラムフローと関数呼び出しコマンド
    - [ ] 7.2.5 Jack-VM-Hackプラットフォームにおけるプログラム要素
    - [ ] 7.2.6 VMプログラムの例
  - [ ] 7.3 実装
    - [ ] 7.3.1 Hackプラットフォームの標準VMマッピング（第1部）
    - [ ] 7.3.2 VM実装の設計案
    - [ ] 7.3.3 プログラムの構造
  - [ ] 7.4 展望
  - [ ] 7.5 プロジェクト
    - [ ] 7.5.1 実装についての提案
    - [ ] 7.5.2 テストプログラム
    - [ ] 7.5.3 助言
    - [ ] 7.5.4 ツール
- [ ] 8章 バーチャルマシン#2：プログラム制御
  - [ ] 8.1 背景
    - [ ] 8.1.1 プログラムフロー
    - [ ] 8.1.2 サブルーチン呼び出し
  - [ ] 8.2 VM仕様（第2部）
    - [ ] 8.2.1 プログラムフローコマンド
    - [ ] 8.2.2 関数呼び出しコマンド
    - [ ] 8.2.3 関数呼び出しプロトコル
    - [ ] 8.2.4 初期化
  - [ ] 8.3 実装
    - [ ] 8.3.1 Hackプラットフォームの標準VMマッピング（第2部）
    - [ ] 8.3.2 例
    - [ ] 8.3.3 VM実装の設計案
  - [ ] 8.4 展望
  - [ ] 8.5 プロジェクト
    - [ ] 8.5.1 テストプログラム
    - [ ] 8.5.2 助言
- [ ] 9章 高水準言語
  - [ ] 9.1 背景
    - [ ] 9.1.1 例1：Hello World
    - [ ] 9.1.2 例2：手続きプログラムと配列処理
    - [ ] 9.1.3 例3：抽象データ型
    - [ ] 9.1.4 例4：リンクリストの実装
  - [ ] 9.2 Jack言語仕様
    - [ ] 9.2.1 シンタックス要素
    - [ ] 9.2.2 プログラム構造
    - [ ] 9.2.3 変数
    - [ ] 9.2.4 文
    - [ ] 9.2.5 式
    - [ ] 9.2.6 サブルーチン呼び出し
    - [ ] 9.2.7 Jack標準ライブラリ
  - [ ] 9.3 Jackアプリケーションを書く
  - [ ] 9.4 展望
  - [ ] 9.5 プロジェクト
    - [ ] 9.5.1 Jackプログラムのコンパイルと実行
- [ ] 10章 コンパイラ#1：構文解析
  - [ ] 10.1 背景
    - [ ] 10.1.1 字句解析
    - [ ] 10.1.2 文法
    - [ ] 10.1.3 構文解析
  - [ ] 10.2 仕様
    - [ ] 10.2.1 Jack言語の文法
    - [ ] 10.2.2 Jack言語のための構文解析器
    - [ ] 10.2.3 構文解析器への入力
    - [ ] 10.2.4 構文解析器の出力
  - [ ] 10.3 実装
    - [ ] 10.3.1 JackAnalyzerモジュール
    - [ ] 10.3.2 JackTokenizerモジュール
    - [ ] 10.3.3 CompilationEngineモジュール
  - [ ] 10.4 展望
  - [ ] 10.5 プロジェクト
    - [ ] 10.5.1 テストプログラム
    - [ ] 10.5.2 第1段階：トークナイザ
    - [ ] 10.5.3 第2段階：パーサ
- [ ] 11章 コンパイラ#2：コード生成
  - [ ] 11.1 背景
    - [ ] 11.1.1 データ変換
    - [ ] 11.1.2 コマンド変換
  - [ ] 11.2 仕様
    - [ ] 11.2.1 バーチャルマシンへの標準マッピング
    - [ ] 11.2.2 コンパイルの例
  - [ ] 11.3 実装
    - [ ] 11.3.1 JackCompilerモジュール
    - [ ] 11.3.2 JackTokenizerモジュール
    - [ ] 11.3.3 SymbolTableモジュール
    - [ ] 11.3.4 VMWriterモジュール
    - [ ] 11.3.5 CompilationEngineモジュール
  - [ ] 11.4 展望
  - [ ] 11.5 プロジェクト
    - [ ] 11.5.1 第1段階：シンボルテーブル
    - [ ] 11.5.2 第2段階：コード生成
    - [ ] 11.5.3 テストプログラム
- [ ] 12章 オペレーティングシステム
  - [ ] 12.1 背景
    - [ ] 12.1.1 数学操作
    - [ ] 12.1.2 数字の文字列表示
    - [ ] 12.1.3 メモリ管理
    - [ ] 12.1.4 可変長な配列と文字列
    - [ ] 12.1.5 入出力管理
    - [ ] 12.1.6 グラフィック出力
    - [ ] 12.1.7 キーボード操作
  - [ ] 12.2 Jack OSの仕様
    - [ ] 12.2.1 Math
    - [ ] 12.2.2 String
    - [ ] 12.2.3 Array
    - [ ] 12.2.4 Output
    - [ ] 12.2.5 Screen
    - [ ] 12.2.6 Keyboard
    - [ ] 12.2.7 Memory
    - [ ] 12.2.8 Sys
  - [ ] 12.3 実装
    - [ ] 12.3.1 Math
    - [ ] 12.3.2 String
    - [ ] 12.3.3 Array
    - [ ] 12.3.4 Output
    - [ ] 12.3.5 Screen
    - [ ] 12.3.6 Keyboard
    - [ ] 12.3.7 Memory
    - [ ] 12.3.8 Sys
  - [ ] 12.4 展望
  - [ ] 12.5 プロジェクト
    - [ ] 12.5.1 テスト方法
    - [ ] 12.5.2 OSクラスとテストプログラム
- [ ] 13章 さらに先へ
  - [ ] 13.1 ハードウェアの実現
  - [ ] 13.2 ハードウェアの改良
  - [ ] 13.3 高水準言語
  - [ ] 13.4 最適化
  - [ ] 13.5 通信
- [ ] 付録A ハードウェア記述言語（HDL）
  - [ ] A.1 例題
  - [ ] A.2 規則
  - [ ] A.3 ハードウェアシミュレータへの回路の読み込み
  - [ ] A.4 回路ヘッダ（インターフェイス）
  - [ ] A.5 回路ボディ（実装）
    - [ ] A.5.1 パーツ
    - [ ] A.5.2 ピンと接続
    - [ ] A.5.3 バス
  - [ ] A.6 ビルトイン回路
  - [ ] A.7 順序回路
    - [ ] A.7.1 クロック
    - [ ] A.7.2 クロック回路とピン
    - [ ] A.7.3 フィードバックループ
  - [ ] A.8 回路操作の視覚化
  - [ ] A.9 新しいビルトイン回路
- [ ] 付録B テストスクリプト言語
  - [ ] B.1 ファイルフォーマットと使用方法
  - [ ] B.2 ハードウェアシミュレータでの回路テスト
    - [ ] B.2.1 例
    - [ ] B.2.2 データ型と変数
    - [ ] B.2.3 スクリプトコマンド
    - [ ] B.2.4 ビルトイン回路の変数とメソッド
    - [ ] B.2.5 最後の例
    - [ ] B.2.6 デフォルトスクリプト
  - [ ] B.3 CPUエミュレータでの機械語プログラムのテスト
    - [ ] B.3.1 例
    - [ ] B.3.2 変数
    - [ ] B.3.3 コマンド
    - [ ] B.3.4 デフォルトスクリプト
  - [ ] B.4 VMエミュレータでのVMプログラムのテスト
    - [ ] B.4.1 例
    - [ ] B.4.2 変数
    - [ ] B.4.3 コマンド
    - [ ] B.4.4 デフォルトスクリプト
- [ ] 付録C Nand2tetris Software Suiteの使い方
  - [ ] C.1 ソフトウェアについて
  - [ ] C.2 Nand2tetrisソフトウェアツール
  - [ ] C.3 ソフトウェアツールの実行方法
  - [ ] C.4 使用方法
  - [ ] C.5 ソースコード

## Memo

github https://github.com/rhedshi/nand2tetris
